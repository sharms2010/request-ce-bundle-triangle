<%@page import="java.text.ParseException"%>
<%@page import="java.text.SimpleDateFormat"%> 
<%@page import="java.util.List"%>
<%@page import="org.w3c.dom.Node"%>
<%@page import="java.util.LinkedHashMap"%>
<%@page import="javax.xml.xpath.XPathConstants"%>
<%@page import="org.w3c.dom.NodeList"%>
<%@page import="javax.xml.xpath.XPathExpression"%>
<%@page import="javax.xml.xpath.XPathFactory"%>
<%@page import="javax.xml.xpath.XPath"%>
<%@page import="org.xml.sax.InputSource"%>
<%@page import="java.io.StringReader"%>
<%@page import="org.w3c.dom.Document"%>
<%@page import="javax.xml.parsers.DocumentBuilderFactory"%>
<%@page import="javax.xml.parsers.DocumentBuilder"%>
<%@page import="java.util.Map"%>
<%!
    public static class Task extends TaskModel implements Comparable<Task> {
        // Define a simple date format for parsing the create date value which
        // is used in the compareTo method for sorting.
        private static final SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_SIMPLE);
        
        /***********************************************************************
         * Member Variables
         **********************************************************************/

        private TaskMessage[] messages = null;
        private Map<String,String> resultsMap = null;
        private String createDate;
        private String id;
        private String modifiedDate;
        private String name;
        private String nodeId;
        private String sourceId;
        private String status;
        private String treeName;
        private String token;
        private String defName;
        private String results;
        private String visible;
        private String runId;
        private String originatingRunId;
        private String originatingTreeName;
        
        /***********************************************************************
         * Constructors
         **********************************************************************/
        
        /**
         * Constructor that takes a Map (parsed from JSON object) that should be
         * used when retrieving Task records from the task api.
         */
        public Task(Map<String,Object> taskObject) {
            this.createDate = convertDate((String)taskObject.get("createdAt"));
            this.id = Long.toString((Long)taskObject.get("id"));
            this.modifiedDate = convertDate((String)taskObject.get("updatedAt"));
            this.name = (String)taskObject.get("nodeName");
            this.nodeId = (String)taskObject.get("nodeId");
            this.status = (String)taskObject.get("status");
            this.token = (String)taskObject.get("token");
            this.defName = (String)taskObject.get("definitionId");
            this.results = (String)taskObject.get("results");
            // Visible is always set to "Yes" because v1 of the task api only
            // retrieves visible tasks, there is no option to include tasks that
            // are not marked as visible.
            this.visible = "Yes";
            // Get the related task messages and add them to the array of
            // messages for this instance.
            List<Map<String,Object>> taskMessageObjects = (List)taskObject.get("messages");
            this.messages = new TaskMessage[taskMessageObjects.size()];
            for(int i=0; i<taskMessageObjects.size(); i++) {
                this.messages[i] = new TaskMessage(taskMessageObjects.get(i));
                this.messages[i].setTaskId(((Long)taskObject.get("id")).toString());
            }
        }
        
        /***********************************************************************
         * Accessors
         **********************************************************************/

        public TaskMessage[] getMessages() {
            return messages;
        }

        public String getResult(String name) {
            return getResultsMap().get(name);
        }
        
        public Map<String,String> getResultsMap() {
            if (this.resultsMap == null) {
                try {
                    // Do the gross xml parsing stuff.  We need to create an xml
                    // document using the results data.  Then we create an xpath
                    // expression to get the result nodes from the xml.
                    DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
                    Document document = db.parse(new InputSource(new StringReader(getResults())));
                    XPath xpath = XPathFactory.newInstance().newXPath();
                    XPathExpression expression = xpath.compile("/results/result");
                    // Get the matching nodes.
                    NodeList nodes = (NodeList)expression.evaluate(document, XPathConstants.NODESET);
                    // Iterate through each of the matching nodes, creating an
                    // entry in the hash for each node.
                    this.resultsMap = new LinkedHashMap<String, String>();
                    for (int i=0; i<nodes.getLength(); i++) {
                        Node node = nodes.item(i);
                        String name = node.getAttributes().getNamedItem("name").getNodeValue();
                        String value = node.getTextContent();
                        this.resultsMap.put(name, value);
                    }
                } catch (Exception e) {
                    throw new RuntimeException("Unable to parse task results xml", e);
                } 
            }
            return this.resultsMap;
        }

        public boolean hasMessages() {
            return messages.length > 0;
        }

        public String getCreateDate() { return this.createDate; }
        public String getId() { return this.id; }
        public String getModifiedDate() { return this.modifiedDate; }
        public String getName() { return this.name; }
        public String getNodeId() { return this.nodeId; }
        public String getSourceId() { return this.sourceId; }
        public String getStatus() { return this.status; }
        public String getTreeName() { return this.treeName; }
        public String getToken() { return this.token; }
        public String getDefName() { return this.defName; }
        public String getResults() { return this.results; }
        public String getVisible() { return this.visible; }
        public String getRunId() { return this.runId; }
        public String getOriginatingRunId() { return this.originatingRunId; }
        public String getOriginatingTreeName()  { return this.originatingTreeName; }
        
        public void setSourceId(String sourceId) { this.sourceId = sourceId; }
        public void setTreeName(String treeName) { this.treeName = treeName; }
        public void setRunId(String runId) { this.runId = runId; }
        public void setOriginatingRunId(String originatingRunId) { this.originatingRunId = originatingRunId; }
        public void setOriginatingTreeName(String originatingTreeName) { this.originatingTreeName = originatingTreeName; }
        
        /***********************************************************************
         * Comparable
         **********************************************************************/
        
        public int compareTo(Task task) {
            try {
                return dateFormat.parse(getCreateDate()).compareTo(dateFormat.parse(task.getCreateDate()));
            } catch (ParseException e) {
                throw new RuntimeException("Unable to parse create date.", e);
            }
        }
    }
%>